-- =========================================================
-- Afet Yönetimi – PostgreSQL tam kurulum betiği 
-- =========================================================

-- 0) Gerekli eklentiler
CREATE EXTENSION IF NOT EXISTS pgcrypto;
CREATE EXTENSION IF NOT EXISTS postgis;

-- 1) Yardımcı şema
CREATE SCHEMA IF NOT EXISTS app_api;

-- 2) Tablolar
-- 2.1) users
CREATE TABLE IF NOT EXISTS public.users (
  id                   integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  username             text,
  password_hash        text,
  role                 text,                       
  name                 text,
  surname              text,
  email                text,
  email_verified       boolean DEFAULT false,
  is_verified          boolean DEFAULT false,
  verify_token         text,
  verify_expires       timestamptz,
  is_active            boolean DEFAULT true,
  deleted_by           text,
  deleted_by_role      text,
  deleted_by_id        integer,
  deleted_at           timestamptz,
  reset_code           text,
  reset_expires        timestamptz,
  two_factor_secret    text,
  two_factor_enabled   boolean DEFAULT false,
  two_factor_norm_hash text
);

-- 2.2) olaylar (olay türleri)
CREATE TABLE IF NOT EXISTS public.olaylar (
  o_id                     integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  o_adi                    text,
  active                   boolean DEFAULT true,
  created_by_name          text,
  created_by_role_name     text,
  created_by_id            integer,
  created_at               timestamptz DEFAULT now(),
  deactivated_by_name      text,
  deactivated_by_role_name text,
  deactivated_by_id        integer,
  deactivated_at           timestamptz
);

-- 2.3) olay (saha kayıtları)
CREATE TABLE IF NOT EXISTS public.olay (
  olay_id                  integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  enlem                    double precision,
  boylam                   double precision,
  olay_turu                integer REFERENCES public.olaylar(o_id) ON UPDATE CASCADE ON DELETE SET NULL,
  aciklama                 text,
  geom                     geometry(Point,4326),
  created_by_name          text,
  created_by_role_name     text,
  created_by_id            integer,
  active                   boolean DEFAULT true,
  deactivated_by_name      text,
  deactivated_by_role_name text,
  deactivated_by_id        integer,
  deactivated_at           timestamptz,
  created_at               timestamptz DEFAULT now(),
  photo_urls               text NOT NULL DEFAULT '[]',
  video_urls               text NOT NULL DEFAULT '[]'
);

-- 2.4) kayit (isteğe bağlı eşleştirme tablosu)
CREATE TABLE IF NOT EXISTS public.kayit (
  p_id    integer,
  olay_id integer REFERENCES public.olay(olay_id) ON DELETE CASCADE
);

-- 3) Indexler
CREATE INDEX IF NOT EXISTS users_username_idx ON public.users (lower(btrim(username)));
CREATE INDEX IF NOT EXISTS users_email_idx    ON public.users (lower(btrim(email)));
CREATE UNIQUE INDEX IF NOT EXISTS users_supervisor_totp_norm_uniq
  ON public.users (two_factor_norm_hash)
  WHERE role='supervisor' AND two_factor_norm_hash IS NOT NULL;

-- 4) Kolon varsayılanları / tip düzeltmeleri (idempotent)
ALTER TABLE public.olay  ALTER COLUMN photo_urls SET DEFAULT '[]';
ALTER TABLE public.olay  ALTER COLUMN photo_urls SET NOT NULL;
ALTER TABLE public.olay  ALTER COLUMN video_urls SET DEFAULT '[]';
ALTER TABLE public.olay  ALTER COLUMN video_urls SET NOT NULL;

-- Eski tekil kolonlar görülürse düşür (legacy)
DO $$
BEGIN
  IF EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema='public' AND table_name='olay' AND column_name='photo_url'
  ) THEN
    EXECUTE 'ALTER TABLE public.olay DROP COLUMN photo_url CASCADE';
  END IF;
  IF EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema='public' AND table_name='olay' AND column_name='video_url'
  ) THEN
    EXECUTE 'ALTER TABLE public.olay DROP COLUMN video_url CASCADE';
  END IF;
END$$;

-- 5) Parola politikası ve yardımcı fonksiyonlar
CREATE OR REPLACE FUNCTION app_api._check_password_policy(pw text)
RETURNS void LANGUAGE plpgsql AS $fn$
BEGIN
  IF pw IS NULL
     OR length(pw) < 8
     OR pw !~ '[[:lower:]]'
     OR pw !~ '[[:upper:]]'
     OR pw !~ '[^[:alnum:][:space:]]'
  THEN
    RAISE EXCEPTION 'Şifre politikası: En az 8 karakter, en az bir küçük harf, en az bir büyük harf ve en az bir noktalama/simge.' USING ERRCODE='P0001';
  END IF;
END
$fn$;

CREATE OR REPLACE FUNCTION app_api._normalize_base32(b32 text)
RETURNS text LANGUAGE sql AS
$$ SELECT NULLIF(regexp_replace(upper(COALESCE(b32,'')), '[^A-Z2-7]', '', 'g'), '') $$;

CREATE OR REPLACE FUNCTION app_api._sha256_hex(t text)
RETURNS text LANGUAGE sql AS
$$ SELECT CASE WHEN t IS NULL THEN NULL ELSE encode(digest(t,'sha256'),'hex') END $$;

CREATE OR REPLACE FUNCTION app_api._extract_plain_from_query(q text)
RETURNS text LANGUAGE plpgsql AS $fn$
DECLARE m text;
BEGIN
  IF q IS NULL THEN RETURN NULL; END IF;
  m := substring(q from $rx$crypt\('([^']+)'\s*,\s*gen_salt\('bf'[^\)]*\)\)$rx$);
  RETURN m;
END
$fn$;

-- 6) users tetikleyici fonksiyonları
CREATE OR REPLACE FUNCTION app_api.users_before_ins_upd()
RETURNS trigger LANGUAGE plpgsql AS $fn$
DECLARE plain text; curq text;
BEGIN
  IF TG_OP = 'INSERT' OR (TG_OP = 'UPDATE' AND (OLD.password_hash IS DISTINCT FROM NEW.password_hash)) THEN
    plain := current_setting('app.password_plain', true);
    IF plain IS NULL THEN
      SELECT query INTO curq FROM pg_stat_activity WHERE pid = pg_backend_pid();
      plain := app_api._extract_plain_from_query(curq);
    END IF;
    IF plain IS NULL THEN
      RAISE EXCEPTION 'Şifre doğrulaması için ya düz parolayı SQL içinde crypt(''PAROLA'', gen_salt(''bf'')) şeklinde verin ya da INSERT öncesi SELECT set_config(''app.password_plain'',''PAROLA'',true) çağırın.' USING ERRCODE='P0001';
    END IF;
    PERFORM app_api._check_password_policy(plain);
  END IF;
  RETURN NEW;
END
$fn$;

CREATE OR REPLACE FUNCTION app_api.users_prevent_global_dup()
RETURNS trigger LANGUAGE plpgsql AS $fn$
DECLARE v_dummy int;
BEGIN
  IF NEW.username IS NOT NULL THEN NEW.username := NULLIF(btrim(NEW.username),''); END IF;
  IF NEW.email    IS NOT NULL THEN NEW.email    := NULLIF(btrim(NEW.email),   ''); END IF;

  IF TG_OP='INSERT' THEN
    SELECT 1 INTO v_dummy FROM public.users u
    WHERE (lower(btrim(u.username)) = lower(COALESCE(NEW.username,'')) OR lower(btrim(u.email)) = lower(COALESCE(NEW.email,'')))
    LIMIT 1;
    IF FOUND THEN RAISE EXCEPTION 'active_username_or_email_exists' USING ERRCODE='P0002'; END IF;
  ELSIF TG_OP='UPDATE' THEN
    IF COALESCE(OLD.is_active,false)=false AND COALESCE(NEW.is_active,true)=true THEN RETURN NEW; END IF;

    IF (COALESCE(NEW.username,'') IS DISTINCT FROM COALESCE(OLD.username,''))
       OR (COALESCE(NEW.email,'') IS DISTINCT FROM COALESCE(OLD.email,'')) THEN
      SELECT 1 INTO v_dummy FROM public.users u
      WHERE u.id <> NEW.id
        AND (lower(btrim(u.username)) = lower(COALESCE(NEW.username,'')) OR lower(btrim(u.email)) = lower(COALESCE(NEW.email,'')))
      LIMIT 1;
      IF FOUND THEN RAISE EXCEPTION 'active_username_or_email_exists' USING ERRCODE='P0002'; END IF;
    END IF;
  END IF;
  RETURN NEW;
END
$fn$;

CREATE OR REPLACE FUNCTION app_api.users_prevent_useless_activate()
RETURNS trigger LANGUAGE plpgsql AS $fn$
BEGIN
  IF TG_OP='UPDATE'
     AND (TG_ARGV[0] IS NULL OR TG_ARGV[0] <> 'bypass')
     AND COALESCE(OLD.is_active,true)=true
     AND COALESCE(NEW.is_active,true)=true THEN
    RAISE EXCEPTION 'active liği true olan bir kullanıcının active liği true olamaz' USING ERRCODE='P0004';
  END IF;
  RETURN NEW;
END
$fn$;

CREATE OR REPLACE FUNCTION app_api.users_totp_before()
RETURNS trigger LANGUAGE plpgsql AS $fn$
DECLARE b32 text; h text; bypass text;
BEGIN
  bypass := current_setting('app.bypass_totp_check', true);
  IF bypass = '1' THEN RETURN NEW; END IF;

  IF NEW.role IS DISTINCT FROM 'supervisor' THEN
    NEW.two_factor_norm_hash := NULL;
    RETURN NEW;
  END IF;

  IF NEW.two_factor_secret IS NULL OR NEW.two_factor_secret = '' THEN
    NEW.two_factor_enabled := false;
    NEW.two_factor_norm_hash := NULL;
    RETURN NEW;
  END IF;

  IF NEW.two_factor_secret LIKE 'enc:v1:%' THEN
    RAISE EXCEPTION 'totp_plain_required' USING ERRCODE='P0003';
  END IF;

  b32 := app_api._normalize_base32(NEW.two_factor_secret);
  IF b32 IS NULL OR b32 = '' THEN
    RAISE EXCEPTION 'invalid_base32' USING ERRCODE='P0003';
  END IF;

  h := app_api._sha256_hex(b32);
  PERFORM 1 FROM public.users u
    WHERE u.role='supervisor'
      AND u.two_factor_norm_hash = h
      AND (TG_OP='INSERT' OR u.id <> NEW.id)
    LIMIT 1;
  IF FOUND THEN
    RAISE EXCEPTION 'base32_conflict' USING ERRCODE='P0003';
  END IF;

  NEW.two_factor_norm_hash := h;
  NEW.two_factor_enabled := true;
  RETURN NEW;
END
$fn$;

CREATE OR REPLACE FUNCTION app_api.users_after_status_change()
RETURNS trigger LANGUAGE plpgsql AS $fn$
BEGIN
  IF TG_OP='UPDATE' AND COALESCE(OLD.is_active,false)=false AND COALESCE(NEW.is_active,true)=true THEN
    UPDATE public.olay o
      SET active = TRUE,
          deactivated_by_name = NULL,
          deactivated_by_role_name = NULL,
          deactivated_by_id = NULL,
          deactivated_at = NULL
    WHERE COALESCE(o.active,false)=false
      AND (o.created_by_id = NEW.id OR (o.created_by_id IS NULL AND o.created_by_name = NEW.username));

    IF NEW.role = 'supervisor' THEN
      UPDATE public.olaylar t
        SET active = TRUE,
            deactivated_by_name = NULL,
            deactivated_by_role_name = NULL,
            deactivated_by_id = NULL,
            deactivated_at = NULL
      WHERE COALESCE(t.active,false)=false
        AND (t.created_by_id = NEW.id OR (t.created_by_id IS NULL AND t.created_by_name = NEW.username));
    END IF;
  END IF;
  RETURN NEW;
END
$fn$;

CREATE OR REPLACE FUNCTION app_api.users_after_ins_upd()
RETURNS trigger LANGUAGE plpgsql AS $fn$
BEGIN
  IF NEW.two_factor_secret IS NOT NULL
     AND NEW.two_factor_secret <> ''
     AND NEW.two_factor_secret NOT LIKE 'enc:v1:%' THEN
    PERFORM pg_notify('encrypt_totp', NEW.id::text);
  END IF;
  RETURN NEW;
END
$fn$;

CREATE OR REPLACE FUNCTION app_api.users_enforce_update_rows()
RETURNS trigger LANGUAGE plpgsql AS $$ BEGIN RETURN NULL; END $$;

-- 7) olay/olaylar tetikleyici fonksiyonları
CREATE OR REPLACE FUNCTION app_api.olay_fill_deactivated_meta()
RETURNS trigger LANGUAGE plpgsql AS $fn$
DECLARE actor_name text := current_setting('app.actor_name', true);
        actor_role text := current_setting('app.actor_role', true);
        actor_id   int  := NULLIF(current_setting('app.actor_id', true),'')::int;
BEGIN
  IF COALESCE(OLD.active,true)=true AND COALESCE(NEW.active,false)=false THEN
    IF NEW.deactivated_by_name IS NULL THEN NEW.deactivated_by_name := COALESCE(actor_name, current_user); END IF;
    IF NEW.deactivated_by_role_name IS NULL THEN NEW.deactivated_by_role_name := COALESCE(actor_role, 'db_user'); END IF;
    IF NEW.deactivated_by_id IS NULL THEN NEW.deactivated_by_id := actor_id; END IF;
    IF NEW.deactivated_at IS NULL THEN NEW.deactivated_at := NOW(); END IF;
  END IF;
  RETURN NEW;
END
$fn$;

CREATE OR REPLACE FUNCTION app_api.olaylar_fill_deactivated_meta()
RETURNS trigger LANGUAGE plpgsql AS $fn$
DECLARE actor_name text := current_setting('app.actor_name', true);
        actor_role text := current_setting('app.actor_role', true);
        actor_id   int  := NULLIF(current_setting('app.actor_id', true),'')::int;
BEGIN
  IF COALESCE(OLD.active,true)=true AND COALESCE(NEW.active,false)=false THEN
    IF NEW.deactivated_by_name IS NULL THEN NEW.deactivated_by_name := COALESCE(actor_name, current_user); END IF;
    IF NEW.deactivated_by_role_name IS NULL THEN NEW.deactivated_by_role_name := COALESCE(actor_role, 'db_user'); END IF;
    IF NEW.deactivated_by_id IS NULL THEN NEW.deactivated_by_id := actor_id; END IF;
    IF NEW.deactivated_at IS NULL THEN NEW.deactivated_at := NOW(); END IF;
  END IF;
  RETURN NEW;
END
$fn$;

-- 8) Query Tool fonksiyonları (SECURITY DEFINER)
CREATE OR REPLACE FUNCTION app_api.create_user(
  p_username text, p_password text, p_role text, p_name text, p_surname text, p_email text
)
RETURNS integer LANGUAGE plpgsql SECURITY DEFINER AS $fn$
DECLARE v_id integer;
BEGIN
  IF p_role NOT IN ('user','supervisor','admin') THEN
    RAISE EXCEPTION 'Geçersiz rol: %', p_role USING ERRCODE='P0001';
  END IF;

  PERFORM app_api._check_password_policy(p_password);
  PERFORM set_config('app.password_plain', p_password, true);

  INSERT INTO public.users (username, password_hash, role, name, surname, email, email_verified, is_verified, is_active)
  VALUES (p_username, crypt(p_password, gen_salt('bf',10)), p_role, NULLIF(p_name,''), NULLIF(p_surname,''), p_email, TRUE, TRUE, TRUE)
  RETURNING id INTO v_id;

  PERFORM set_config('app.password_plain', NULL, true);
  RETURN v_id;
EXCEPTION WHEN OTHERS THEN
  PERFORM set_config('app.password_plain', NULL, true);
  RAISE;
END
$fn$;

CREATE OR REPLACE FUNCTION app_api.set_user_totp(p_user_id integer, p_base32 text)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER AS $fn$
BEGIN
  UPDATE public.users
  SET two_factor_secret = NULLIF(p_base32,''),
      two_factor_enabled = (p_base32 IS NOT NULL AND p_base32 <> '')
  WHERE id = p_user_id;
END
$fn$;

CREATE OR REPLACE FUNCTION app_api.activate_user(p_user_id integer)
RETURNS TABLE (id integer, username text, is_active boolean)
LANGUAGE plpgsql SECURITY DEFINER AS $fn$
DECLARE cur record;
BEGIN
  SELECT id, username, COALESCE(is_active,true) AS is_active
  INTO cur FROM public.users WHERE id = p_user_id FOR UPDATE;

  IF NOT FOUND THEN RAISE EXCEPTION 'user_not_found' USING ERRCODE='P0005'; END IF;
  IF cur.is_active = TRUE THEN
    RAISE EXCEPTION 'active liği true olan bir kullanıcının active liği true olamaz' USING ERRCODE='P0004';
  END IF;

  UPDATE public.users
  SET is_active = TRUE, deleted_by=NULL, deleted_by_role=NULL, deleted_by_id=NULL, deleted_at=NULL
  WHERE id = p_user_id AND COALESCE(is_active, FALSE) = FALSE
  RETURNING id, username, is_active INTO id, username, is_active;

  RETURN NEXT;
END
$fn$;

CREATE OR REPLACE FUNCTION app_api.hard_delete_user(p_user_id integer)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER AS $fn$
DECLARE v_id integer;
BEGIN
  SELECT id INTO v_id FROM public.users WHERE id = p_user_id FOR UPDATE;
  IF NOT FOUND THEN RAISE EXCEPTION 'user_not_found' USING ERRCODE='P0005'; END IF;
  DELETE FROM public.users WHERE id = p_user_id;
END
$fn$;

-- 9) Trigger’lar (düşür & kur)
DROP TRIGGER IF EXISTS trg_users_prevent_global_dup          ON public.users;
DROP TRIGGER IF EXISTS trg_users_before_ins_upd              ON public.users;
DROP TRIGGER IF EXISTS trg_users_totp_before                 ON public.users;
DROP TRIGGER IF EXISTS trg_users_guard_reactivate            ON public.users;
DROP TRIGGER IF EXISTS trg_users_enforce_is_active_update    ON public.users;
DROP TRIGGER IF EXISTS trg_users_after_ins_upd               ON public.users;
DROP TRIGGER IF EXISTS trg_olay_fill_deactivated             ON public.olay;
DROP TRIGGER IF EXISTS trg_olaylar_fill_deactivated          ON public.olaylar;

CREATE TRIGGER trg_users_prevent_global_dup
BEFORE INSERT OR UPDATE ON public.users
FOR EACH ROW EXECUTE FUNCTION app_api.users_prevent_global_dup();

CREATE TRIGGER trg_users_before_ins_upd
BEFORE INSERT OR UPDATE ON public.users
FOR EACH ROW EXECUTE FUNCTION app_api.users_before_ins_upd();

CREATE TRIGGER trg_users_totp_before
BEFORE INSERT OR UPDATE OF two_factor_secret, two_factor_enabled, role ON public.users
FOR EACH ROW EXECUTE FUNCTION app_api.users_totp_before();

CREATE TRIGGER trg_users_guard_reactivate
BEFORE UPDATE OF is_active ON public.users
FOR EACH ROW EXECUTE FUNCTION app_api.users_prevent_useless_activate();

CREATE TRIGGER trg_users_enforce_is_active_update
AFTER UPDATE ON public.users
FOR EACH STATEMENT EXECUTE FUNCTION app_api.users_enforce_update_rows();

CREATE TRIGGER trg_users_after_ins_upd
AFTER INSERT OR UPDATE OF two_factor_secret ON public.users
FOR EACH ROW EXECUTE FUNCTION app_api.users_after_ins_upd();

CREATE TRIGGER trg_olay_fill_deactivated
BEFORE UPDATE OF active ON public.olay
FOR EACH ROW EXECUTE FUNCTION app_api.olay_fill_deactivated_meta();

CREATE TRIGGER trg_olaylar_fill_deactivated
BEFORE UPDATE OF active ON public.olaylar
FOR EACH ROW EXECUTE FUNCTION app_api.olaylar_fill_deactivated_meta();

-- 10) Yardımcı: olaylar(o_adi) benzersiz (uygun olduğunda)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname='olaylar_o_adi_key'
  ) THEN
    BEGIN
      ALTER TABLE public.olaylar ADD CONSTRAINT olaylar_o_adi_key UNIQUE (o_adi);
    EXCEPTION WHEN duplicate_table THEN
      -- yoksay
    END;
  END IF;
END$$;


